{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pangadfs is a pandas-based (python) genetic algorithm framework for fantasy sports. It uses a plugin architecture to enable maximum flexibility while also providing a fully-functional implementation of a genetic algorithm for lineup optimization. pangadfs-configapp is a plugin that provides for structured configuration of pangadfs applications. Specifically, it offers an OptimizeConfig in the pangadfs.optimize namespace to coordinate the steps of lineup optimization using an AppSettings object. Documentation : https://sansbacon.github.io/pangadfs-configapp/ Source Code : https://github.com/sansbacon/pangadfs-configapp The key pangadfs-configapp feature is that it uses python dataclasses to provide structured configuration for pangadfs apps. The basic app example in pangadfs uses a dictionary, which is not as robust because it does not require certain keys to be present and that they have specific types. Pangadfs-configapp uses the dacite library to create a configuration object from an ordinary dictionary while supplying sensible defaults for all missing values. Requirements \u00b6 Python 3.8+ dacite 1.0+ Installation \u00b6 $ pip install pangadfs-configapp Example \u00b6 Create It \u00b6 An optimizer app using pangadfs-configapp could look like the following import json from pathlib import Path from stevedore.driver import DriverManager from stevedore.named import NamedExtensionManager from pangadfs.ga import GeneticAlgorithm from pangadfs_configapp.gasettings import ctx_from_dict # setup configuration DATADIR = Path ( __file__ ) . parent / 'appdata' data = json . loads (( DATADIR / 'config.json' ) . read_text ()) ctx = ctx_from_dict ( data ) ctx . ga_settings . csvpth = DATADIR / ctx . ga_settings . csvpth # setup plugin managers dmgrs = { k : DriverManager ( namespace = f 'pangadfs. { k } ' , name = v , invoke_on_load = True ) for k , v in ctx . plugin_settings . driver_managers . items () } emgrs = { k : NamedExtensionManager ( namespace = f 'pangadfs. { k } ' , names = v , invoke_on_load = True , name_order = True ) for k , v in ctx . plugin_settings . extension_managers . items () } # set up GeneticAlgorithm object ga = GeneticAlgorithm ( ctx = ctx , driver_managers = dmgrs , extension_managers = emgrs ) # optimize lineup results = ga . optimize () # show results print ( results [ 'best_lineup' ]) print ( f 'Lineup score: { results [ \"best_score\" ] } ' ) Run it \u00b6 Run the sample application with: $ python pangadfs_configapp/app/app.py INFO:root:Starting generation 1 INFO:root:Best lineup score 153.00000000000003 INFO:root:Lineup unimproved 1 times INFO:root:Starting generation 2 INFO:root:Best lineup score 153.00000000000003 INFO:root:Lineup improved to 155.2 . . . INFO:root:Starting generation 19 INFO:root:Best lineup score 156.3 INFO:root:Lineup improved to 156.5 INFO:root:Starting generation 20 INFO:root:Best lineup score 156.5 INFO:root:Lineup unimproved 1 times player team pos salary proj 0 Saints NO DST 3800 9.8 34 Patrick Mahomes KC QB 8000 26.6 62 Dalvin Cook MIN RB 9500 27.2 68 Nyheim Hines IND RB 4600 15.9 72 Brian Hill ATL RB 4000 12.8 109 Gabriel Davis BUF WR 3000 10.7 136 Keelan Cole Sr. JAX WR 3600 11.9 138 Calvin Ridley ATL WR 7100 21.6 142 Justin Jefferson MIN WR 6300 20.0 Lineup score: 156.5 License \u00b6 This project is licensed under the terms of the MIT license.","title":"pangadfs-configapp"},{"location":"#requirements","text":"Python 3.8+ dacite 1.0+","title":"Requirements"},{"location":"#installation","text":"$ pip install pangadfs-configapp","title":"Installation"},{"location":"#example","text":"","title":"Example"},{"location":"#create-it","text":"An optimizer app using pangadfs-configapp could look like the following import json from pathlib import Path from stevedore.driver import DriverManager from stevedore.named import NamedExtensionManager from pangadfs.ga import GeneticAlgorithm from pangadfs_configapp.gasettings import ctx_from_dict # setup configuration DATADIR = Path ( __file__ ) . parent / 'appdata' data = json . loads (( DATADIR / 'config.json' ) . read_text ()) ctx = ctx_from_dict ( data ) ctx . ga_settings . csvpth = DATADIR / ctx . ga_settings . csvpth # setup plugin managers dmgrs = { k : DriverManager ( namespace = f 'pangadfs. { k } ' , name = v , invoke_on_load = True ) for k , v in ctx . plugin_settings . driver_managers . items () } emgrs = { k : NamedExtensionManager ( namespace = f 'pangadfs. { k } ' , names = v , invoke_on_load = True , name_order = True ) for k , v in ctx . plugin_settings . extension_managers . items () } # set up GeneticAlgorithm object ga = GeneticAlgorithm ( ctx = ctx , driver_managers = dmgrs , extension_managers = emgrs ) # optimize lineup results = ga . optimize () # show results print ( results [ 'best_lineup' ]) print ( f 'Lineup score: { results [ \"best_score\" ] } ' )","title":"Create It"},{"location":"#run-it","text":"Run the sample application with: $ python pangadfs_configapp/app/app.py INFO:root:Starting generation 1 INFO:root:Best lineup score 153.00000000000003 INFO:root:Lineup unimproved 1 times INFO:root:Starting generation 2 INFO:root:Best lineup score 153.00000000000003 INFO:root:Lineup improved to 155.2 . . . INFO:root:Starting generation 19 INFO:root:Best lineup score 156.3 INFO:root:Lineup improved to 156.5 INFO:root:Starting generation 20 INFO:root:Best lineup score 156.5 INFO:root:Lineup unimproved 1 times player team pos salary proj 0 Saints NO DST 3800 9.8 34 Patrick Mahomes KC QB 8000 26.6 62 Dalvin Cook MIN RB 9500 27.2 68 Nyheim Hines IND RB 4600 15.9 72 Brian Hill ATL RB 4000 12.8 109 Gabriel Davis BUF WR 3000 10.7 136 Keelan Cole Sr. JAX WR 3600 11.9 138 Calvin Ridley ATL WR 7100 21.6 142 Justin Jefferson MIN WR 6300 20.0 Lineup score: 156.5","title":"Run it"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"gasettings-reference/","text":"GASettings Reference \u00b6 To be developed . . . problems with autodocumentation.","title":"gasettings"},{"location":"gasettings-reference/#gasettings-reference","text":"To be developed . . . problems with autodocumentation.","title":"GASettings Reference"},{"location":"optimize-reference/","text":"\u00b6 OptimizeConfig \u00b6 optimize ( self , * , ga , ** kwargs ) \u00b6 Creates initial pool Parameters: Name Type Description Default ga GeneticAlgorithm the GeneticAlgorithm instance, required **kwargs keyword arguments for plugins {} Returns: Type Description Dict[str, Any] Dict 'population': np.ndarray, 'fitness': np.ndarray, 'best_lineup': pd.DataFrame, 'best_score': float Source code in pangadfs_configapp/optimize.py def optimize ( self , * , ga : GeneticAlgorithm , ** kwargs ) -> Dict [ str , Any ]: \"\"\"Creates initial pool Args: ga (GeneticAlgorithm): the GeneticAlgorithm instance, **kwargs: keyword arguments for plugins Returns: Dict 'population': np.ndarray, 'fitness': np.ndarray, 'best_lineup': pd.DataFrame, 'best_score': float \"\"\" pop_size = ga . ctx . ga_settings . population_size pool = ga . pool ( csvpth = ga . ctx . ga_settings . csvpth ) cmap = { 'points' : ga . ctx . ga_settings . points_column , 'position' : ga . ctx . ga_settings . position_column , 'salary' : ga . ctx . ga_settings . salary_column } posfilter = ga . ctx . site_settings . posfilter pospool = ga . pospool ( pool = pool , posfilter = posfilter , column_mapping = cmap , flex_positions = ga . ctx . site_settings . flex_positions ) # create dict of index and stat value # this will allow easy lookup later on cmap = { 'points' : ga . ctx . ga_settings . points_column , 'salary' : ga . ctx . ga_settings . salary_column } points = pool [ cmap [ 'points' ]] . values salaries = pool [ cmap [ 'salary' ]] . values # CREATE INITIAL POPULATION initial_population = ga . populate ( pospool = pospool , posmap = ga . ctx . site_settings . posmap , population_size = pop_size ) # apply validators initial_population = ga . validate ( population = initial_population , salaries = salaries , salary_cap = ga . ctx . site_settings . salary_cap ) population_fitness = ga . fitness ( population = initial_population , points = points ) # set overall_max based on initial population omidx = population_fitness . argmax () best_fitness = population_fitness [ omidx ] best_lineup = initial_population [ omidx ] population = initial_population . copy () # CREATE NEW GENERATIONS n_unimproved = 0 for i in range ( 1 , ga . ctx . ga_settings . n_generations + 1 ): if n_unimproved == ga . ctx . ga_settings . stop_criteria : break if ga . ctx . ga_settings . verbose : logging . info ( f 'Starting generation { i } ' ) logging . info ( f 'Best lineup score { best_fitness } ' ) elite = ga . select ( population = population , population_fitness = population_fitness , n = len ( population ) // ga . ctx . ga_settings . elite_divisor , method = ga . ctx . ga_settings . elite_method ) selected = ga . select ( population = population , population_fitness = population_fitness , n = len ( population ), method = ga . ctx . ga_settings . select_method ) # crossover crossed_over = ga . crossover ( population = selected , method = ga . ctx . ga_settings . crossover_method ) # mutation mutated = ga . mutate ( population = crossed_over , mutation_rate = ga . ctx . ga_settings . mutation_rate ) # validation population = ga . validate ( population = np . vstack (( elite , mutated )), salaries = salaries , salary_cap = ga . ctx . site_settings . salary_cap ) # get fitness and compare to prior solutions population_fitness = ga . fitness ( population = population , points = points ) omidx = population_fitness . argmax () generation_max = population_fitness [ omidx ] if generation_max > best_fitness : if ga . ctx . ga_settings . verbose : logging . info ( f 'Lineup improved to { generation_max } ' ) best_fitness = generation_max best_lineup = population [ omidx ] n_unimproved = 0 else : n_unimproved += 1 if ga . ctx . ga_settings . verbose : logging . info ( f 'Lineup unimproved { n_unimproved } times' ) # FINALIZE RESULTS # will break after n_generations or when stop_criteria reached return { 'population' : population , 'fitness' : population_fitness , 'best_lineup' : pool . loc [ best_lineup , :], 'best_score' : best_fitness }","title":"optimize"},{"location":"optimize-reference/#pangadfs_configapp.optimize","text":"","title":"pangadfs_configapp.optimize"},{"location":"optimize-reference/#pangadfs_configapp.optimize.OptimizeConfig","text":"","title":"OptimizeConfig"},{"location":"optimize-reference/#pangadfs_configapp.optimize.OptimizeConfig.optimize","text":"Creates initial pool Parameters: Name Type Description Default ga GeneticAlgorithm the GeneticAlgorithm instance, required **kwargs keyword arguments for plugins {} Returns: Type Description Dict[str, Any] Dict 'population': np.ndarray, 'fitness': np.ndarray, 'best_lineup': pd.DataFrame, 'best_score': float Source code in pangadfs_configapp/optimize.py def optimize ( self , * , ga : GeneticAlgorithm , ** kwargs ) -> Dict [ str , Any ]: \"\"\"Creates initial pool Args: ga (GeneticAlgorithm): the GeneticAlgorithm instance, **kwargs: keyword arguments for plugins Returns: Dict 'population': np.ndarray, 'fitness': np.ndarray, 'best_lineup': pd.DataFrame, 'best_score': float \"\"\" pop_size = ga . ctx . ga_settings . population_size pool = ga . pool ( csvpth = ga . ctx . ga_settings . csvpth ) cmap = { 'points' : ga . ctx . ga_settings . points_column , 'position' : ga . ctx . ga_settings . position_column , 'salary' : ga . ctx . ga_settings . salary_column } posfilter = ga . ctx . site_settings . posfilter pospool = ga . pospool ( pool = pool , posfilter = posfilter , column_mapping = cmap , flex_positions = ga . ctx . site_settings . flex_positions ) # create dict of index and stat value # this will allow easy lookup later on cmap = { 'points' : ga . ctx . ga_settings . points_column , 'salary' : ga . ctx . ga_settings . salary_column } points = pool [ cmap [ 'points' ]] . values salaries = pool [ cmap [ 'salary' ]] . values # CREATE INITIAL POPULATION initial_population = ga . populate ( pospool = pospool , posmap = ga . ctx . site_settings . posmap , population_size = pop_size ) # apply validators initial_population = ga . validate ( population = initial_population , salaries = salaries , salary_cap = ga . ctx . site_settings . salary_cap ) population_fitness = ga . fitness ( population = initial_population , points = points ) # set overall_max based on initial population omidx = population_fitness . argmax () best_fitness = population_fitness [ omidx ] best_lineup = initial_population [ omidx ] population = initial_population . copy () # CREATE NEW GENERATIONS n_unimproved = 0 for i in range ( 1 , ga . ctx . ga_settings . n_generations + 1 ): if n_unimproved == ga . ctx . ga_settings . stop_criteria : break if ga . ctx . ga_settings . verbose : logging . info ( f 'Starting generation { i } ' ) logging . info ( f 'Best lineup score { best_fitness } ' ) elite = ga . select ( population = population , population_fitness = population_fitness , n = len ( population ) // ga . ctx . ga_settings . elite_divisor , method = ga . ctx . ga_settings . elite_method ) selected = ga . select ( population = population , population_fitness = population_fitness , n = len ( population ), method = ga . ctx . ga_settings . select_method ) # crossover crossed_over = ga . crossover ( population = selected , method = ga . ctx . ga_settings . crossover_method ) # mutation mutated = ga . mutate ( population = crossed_over , mutation_rate = ga . ctx . ga_settings . mutation_rate ) # validation population = ga . validate ( population = np . vstack (( elite , mutated )), salaries = salaries , salary_cap = ga . ctx . site_settings . salary_cap ) # get fitness and compare to prior solutions population_fitness = ga . fitness ( population = population , points = points ) omidx = population_fitness . argmax () generation_max = population_fitness [ omidx ] if generation_max > best_fitness : if ga . ctx . ga_settings . verbose : logging . info ( f 'Lineup improved to { generation_max } ' ) best_fitness = generation_max best_lineup = population [ omidx ] n_unimproved = 0 else : n_unimproved += 1 if ga . ctx . ga_settings . verbose : logging . info ( f 'Lineup unimproved { n_unimproved } times' ) # FINALIZE RESULTS # will break after n_generations or when stop_criteria reached return { 'population' : population , 'fitness' : population_fitness , 'best_lineup' : pool . loc [ best_lineup , :], 'best_score' : best_fitness }","title":"optimize()"}]}